# SLA软件框图

![SLA pro_layer.jpg](https://github.com/Realee007/jobbook/blob/master/src/image/SLA%20pro_layer.jpg?raw=true) 

三层架构：

![SLA_pro.jpg](https://github.com/Realee007/jobbook/blob/master/src/image/SLA_pro.jpg?raw=true) 

# 关键技术

## 插件化架构

微内核架构模式（也称为插件化架构模式） 是基于产品的应用程序的**第一选择**，也可以将其嵌入到其他架构模式中。微内核应用模式可以通过插件的形式添加额外的特性到核心系统中，这提供了良好的扩展性，也使得新特性与核心系统隔离开来。

微内核架构主要需要考虑两个方面：**核心系统**和**插件模块**。应用逻辑被划分为独立的插件模块和核心系统，核心系统通常是为特定的条件定义了通用的业务逻辑，而插件模块根据这些规则实现了具体的业务逻辑。微内核本身没有指定任何的实现方式，唯一的规定就是**插件模块之间不要产生依赖**。

核心系统需要了解插件模块的可用性以及如何获取它们。一个通用的方法是使用插件注册表，这个注册表中含有每个插件模块的信息，包括它们的名字、数据规约以及远程访问协议。

插件和核心系统的通信规范包含标准规范和自定义规范。自定义规范的典型使用场景是插件组件是被第三方构建的。在这种情况下，通常是在第三方插件规约和核心系统的标准规约间创建一个**Adapter**来使核心系统不需要知道插件模块的具体细节。当创建标准规范时，从一开始就创建一个版本策略是非常重要的。

#### 模式分析

- 整体灵活性高，能够快速适应不断变化的环境

- 易于部署，插件可以在运行时被动态的添加到核心系统中

- 可测试性高，插件模块能够独立的进行测试

- 性能高，可以只加载需要的模块，移除消耗资源但是没用的功能

- 伸缩性低，微内核架构的系统通常都比较小

- 不易于开发，需要考虑设计和规约管理

  [软件架构笔记参考](https://blog.csdn.net/qq_21397217/article/details/52396346#%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84)

## 算法

### 扫描线填充算法

边相关扫描线填充算法需要建立两张表：**新边表（New Edge Table，NET）**和 **活动边表（Active Edge Table，AET）** 

#### 新边表 NET

记录多边形除水平边外的所有的边，记录在没条扫描线的表中，记录的格式为： 
**x** 当前扫描线与边的交点坐标；**dx**从当前扫描线到下一条扫描线间x的增量（(x2-x1)/(y2-y1)）；**ymax** 该边所交的最高扫描线

#### 活动边表 AET

记录只与当前扫描线相交的边的链表。

NET表建立以后，就知道了多边形所有的边，所以就能开始扫描转换。不同的扫描线相交的边线也不同，当对某一条扫描线进行扫描转换时，我们只需要考虑与它相交的那些边线，也就是活动边表中的边。 

记录的格式还是用 x | dx | ymax 。只是这里 **x** 表示扫描线与边的交点的坐标。

#### 合并NET得到AET

实际计算时不是去算每条条扫面线与多边形边的交点得到活动边表AET（否则也看不到算法意义了），而是用NET补充得到AET。

## 边的扫描转换算法

两个表建立完后，开始扫描转换。整体算法步骤描述如下：

1. 根据给出的多边形顶点坐标，建立NET表；

   ​      求出顶点坐标中最大y值ymax和最小y值ymin。

2. 初始化AET表指针，使它为空。 

3. 执行下列步骤直至NET和AET都为空．
   1.  如NET中的第y类非空，则将其中的所有边取出并插入AET中；
   2. 如果有新边插入AET，则对AET中各边排序；
   3. 对AET中的边两两配对，（1和2为一对，3和4为一对，…），将每对边中x坐标按规则取整，获得有效的填充区段，再填充．
   4. 将当前扫描线纵坐标y值递值1；
   5. 如果AET表中某记录的ymax=yj，则删除该记录 （因为每条边被看作下闭上开的）；
   6. 对AET中剩下的每一条边的x递增dx，即x' = x+ dx ．

### DFS算法

DFS：stack 栈实现，优点不用全部保存点，缺点 存在回溯，效率低。

BFS：queue

### 贪心算法

支撑扫描加速，先按网络划分，再按网格中某个当前点，以最短路径找下一个点，得到一条路径。使用qt concurrent 并行加速，可根据处理器核心数自动调整所使用的线程数。

O(n!/n/k!)

## 开发技术

### 读取.slc文件以及.zip文件

首先对.slc文件进行校验，  
```
.slc文件数据
1. 是一种以切片（轮廓）为基本单位描述CAD实体模型2.5d文件格式,由3D systems 1994年创建。
2. 它在Z轴方向，离散的表示每层平面上轮廓点的信息。
3. 每层轮廓包含最小的Z 轴值、轮廓边界的数量以及与每一个边界相关的顶点和点的坐标。  
    1)边界信息包含顶点的数目，间隙的数目，顶点坐标。
    2)间隙的数目（number of gaps）可以用来表示顶点重复的个数。

4. 最后一层为最顶层，只需表示出Z轴值和一个无符整型（0xFFFFFFFF）。
5. 顶点列表的顺序。逆时针方向表示外部边界，顺时针方向表示内部边界。遵循右手准则，均指向模型实体内部。 
case数据如下：
Z Layer：								    0.1
Number of Boundaries：					    2
Number of Vertices for the 1st Boundary： 	5
Number of Gaps for the 1st Boundary：		0
Vertex List for 1st Boundary：				0.0, 0.0  1.0, 0.0  1.0, 1.0  0.0, 1.0  0.0, 0.0
Number of Vertices for the 2nd Boundary：	5
Number of Gaps for the 2nd Boundary：		0
Vertex List for 2nd Boundary				0.2, 0.2  0.2, 0.8  0.8, 0.8  0.8, 0.2  0.2, 0.2
...
...
...
Top of Part Maximum Z Level：               1 
Termination Value：			                0xFFFFFFFF
```
对于.slc文件会将数据以二进制的形式复写到磁盘。

载入文件进度条显示，使用**回调函数（Callback Functions）** 即通过函数指针调用的函数，`funcA( void(*funcpointer)(int,const char*), int p_num)` ，回调函数典型的例子就是`std::sort(It.begin(),It.end(),Cmp)`,其中Cmp为一个回调函数，其中用户可以自己相应排序准则的比较函数。


**类型转换**   
隐式转换为C中的遗留，显示转换是C++风格   
1. `dynamic_cast`:没有运行时类型检查来保证转换的安全性，比如在类层次结构中基类和子类之间指针或引用的转换。（上行转换：把子类的指针或者引用转换为基类表示是安全的，但下行转换：把基类指针或引用转换为子类指针或引用，由于没有动态类型的检测，所以是不安全的。）  
2. `static_cast`：在类层次间进行上行转换时，`dynamic_cast`和`static_cast`的效果是一样的；在进行下行转换时，`dynamic_cast` 具有类型检查的功能，==更安全== . (由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见<Inside c++ object model>）中，==只有定义了虚函数的类才有虚函数表，没有定义虚函数的类是没有虚函数表的==。)
3. `reinterpret_cast`：非常激进的指针类型转换，在编译期完成，可以转换任何类型的指针，所以极不安全。非极端情况不要使用。   
4. `const_cast`：`const_cast`用于移除类型的`const、volatile`和`__unaligned`属性。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象   







### Zip文件

**使用的minizip  开源项目的代码**

Minizip

https://stackoverflow.com/questions/11370908/how-do-i-use-minizip-on-zlib

### XML文件读写 && UI自动生成

XML具有自我描述性：

```
<?xml version="1.0" encoding="ISO-8859-1"?>
<note>
<to>George</to>
<from>John</from>
<heading>Reminder</heading>
<body>Don't forget the meeting!</body>
</note>
```
第一行为XML声明，它定义了XML的版本(1.0)和所使用的编码 (ISO-8859-1 = Latin-1/西欧字符集).  
下一行描述文档的**根元素**：`<note>`   
接下来4行描述根的4个子元素`(to,from,heading以及body)`   
最后一行定义根元素的结尾:`</note>`   
**XML 文档必须包含根元素**。该元素是所有其他元素的父元素。  
XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。   
所有元素均可拥有子元素：
```
<root>
  <child>
    <subchild>.....</subchild>
  </child>
</root>
```
* XML 文档必须有根元素
* XML 文档必须有关闭标签
* XML 标签对大小写敏感
* XML 元素必须被正确的嵌套
* XML 属性必须加引号

解析XML的方式：
1. DOM(Document Object Model，文档对象模型）
    1. 【缺点】通常需要加载整个XML文档来构造层次结构，消耗资源大。
2. SAX（Simple API for XML)
    1. 【优势】不需要等待所有数据都被处理，分析就能立即开始。









### 程序单一化

**采用文件锁机制实现程序单实例运行**：   
最简单自然的想法，在程序初始化的过程中检查并创建一个空的lock文件，程序结束时再删除。通过判断lock文件是否存在的方式来判断程序是否已经运行。
不过这样做有个bug，如果程序运行过程中异常终止，lock文件没有正常删除，就会导致程序无法再运行。空的lock文件不行，那么考虑在lock文件中加入一点内容，比如进程的**PID号**，然后通过检查该PID号的进程是否还在运行，就能避免上述bug了。
该方法是在脚本中经常用到限制单实例的方法，MySQL 等程序在每次启动前也会检查上次遗留的 mysql.pid 文件。  
其实，该方法是有缺陷的，因为pid会重用。

最后改进：
**给lock文件加互斥锁**，判断是否有锁来确保唯一性，如果线程crash掉而互斥量未释放则将该互斥量转移给正在等待的线程。

---
关于pid重用：  
PID是非负整数。系统和用户有进程数量的限制。进程结束后，pid可以回收，回收的pid可以重复使用,但必须延迟重用（过一段时间才能重用）。  

---

`QtSingleInstance`的例子内在`win`下使用了根据pid号为名创建`lockfile`文件，并对该`lockfile`加上`mutex`并使用`WaitForSingleObject`进行信号状态检测。  
对于可能出现的情况：
1. `WAIT_OBJECT_0`你等待的对象（互斥体）已经正常执行完成或者完成释放。
2. `WAIT_ABANDONED` 互斥体被遗弃。即占用互斥量的线程在释放互斥量之前被终止(exitThread,TerminatedThread)，那么当互斥量被遗弃的时候，系统会自动将互斥量的线程ID设为0，将它的递归计数设为0。然后系统检查有没有其他线程正在等待该互斥量。如果有，那么系统会公平的选择一个正在等待的线程，把对象内部的线程ID设为所选择的那个线程的线程ID，并将递归计数设为1，这样被选择的线程就变成可调度状态了。
3. `WAIT_TIMEOUT`：表示你等待的对象在waittime内还没完成，即超时等待。

于是我们只需要判断状态12或3 即可实现单一实例。

---
在此对于windows下处理器有两种不同的模式:
1. 用户模式User Mode。
2. 内核模式Kernel Mode。  
根据处理器上运行的代码类型，处理器在两个模式之间切换，应用程序在用户模式下运行，核心操作系统组件在内核模式下运行。多数驱动程序也在内核模式下运行，部分驱动程序在用户模式下运行。
当启动用户模式的应用程序时，进程为应用程序提供专用的“虚拟地址空间”和专用的“句柄表格”。由于应用程序的虚拟地址空间为专用空间，一个应用程序无法更改属于其他应用的数据。用户模式应用程序的虚拟地址空间除了为专用空间以外，还会受到限制。在用户模式下运行的处理器无法访问为该操作系统保留的虚拟地址，这样防止应用程序更改并可能损坏关键的操作系统数据。   
在内核模式下运行的所有代码都共享单个虚拟地址空间，这表示内核模型程序未和操作系统和其他内核模式下的程序独立开来，所有当内核模式下程序以外写入错误的虚拟地址，则对于操作系统或者其他内核模式下的程序的数据可能会受到损坏。
![image](https://msdn.microsoft.com/dynimg/IC535109.png)





### QtPlugin 插件模式

Qt的QPluginLoader类 

Qt插件本身是动态库，除此之外，它定义了一组专用的接口，从动态库中导出，供 Qt 的插件管理体系发现和调用。当你选择 Qt 插件项目模板时， Qt Creator 会自动为你插入专用接口相关的模板代码。 





## 平面点集的最小包围圆算法设计

算法思路：（平面内三点确定圆）

1. 对于平面点集P内的多个点p1,p2,......,pi(相对于i个初始边界条件)，确定出一个最小包围圆Ci.
2. 当P中引入新点pi+1时

   1. 若pi+1包含于圆Ci内，则维护原始Ci，作为点集P的最小包围圆，即Ci+1=Ci。
   2. 若pi+1不包含于圆Ci时。则需要对Ci进行更新，而且，圆Ci+1一定经过pi+1.
3. 针对2.2情况，此时最小包围圆是过pi+1且覆盖点集P={p1,p2,......,pi}的最小包围圆.则仿照之前思路：

   1. 取设置Cii的，且通过pi+1和p1,进而逐个扫描判断点集{p2,p3.......pi}。

   2. 当pk都包含于Cii，则维护Cii不变，如果存在pk不包含于Cii则，再次修改Cii，且通过pk和pi+1.再依次对点集{p1,p2,......,pi-1}进行逐个扫描。直到满足。
       算法由两层递归调用，三层循环完成。![mincircle1.png](https://github.com/Realee007/jobbook/blob/master/src/image/mincircle1.png?raw=true) 



改进算法：

1. 最远点优先渐进：由p1,p2,p3确定最小包围圆圆心后，在点集中查询距离圆心C最远的点v，若v在C内则终止。



https://people.inf.ethz.ch/gaertner/subdir/software/miniball.html



  ## MVC

- 表现层（View）：UI
- 逻辑层（Controller）：数据接口，操作控制
- 数据层（Model）：数据保存，打印参数等资源

https://www.cnblogs.com/sols/p/8455279.html

## OpenGL

由于客户机硬件配置，使用的opengl3.1之前的版本。

旧版本的opengl 使用了如`glMatrixMode()`，来选择当前操作的矩阵为“模型视图矩阵”或"投影矩阵"

`glMatrixMode(GL_MODELVIEW),glMatrixMode(GL_PROJECTION)` 并在后续使用`glTranslatef`、 `glPushMatrix` 、`glOrtho`等来对矩阵实现相应操作。



## UML

### 静态视图和动态视图

静态视图:类图，对象图

动态视图：顺序图 ，协作图 

### 时序图和协作图



## 重构

### Extract Method (提取函数)

将大函数按模块拆分成几个小的函数 

### Inline Method (内联函数)

将微不足道的小函数进行整合 

### Replace Temp with Query(以查询取代临时变量) 

将一些临时变量使用get函数替代.

### Replace Method with Method Object(以函数对象取代函数)

当一个特别长的函数，而且函数中含有比较复杂的临时变量，使用上述那些方法不好进行重构时，我们就要考虑将该函数封装成一个类了。这个对应的类的对象就是函数对象。 

## 软件的可靠性

## 软件的可测试性和可维护性

### 软件自检测代码设计



# Unity开发

Unity是一个专业的3D应用/游戏开发引擎，最大的特色是**采用了“基于组件”的设计方式**。软件架构有别于传统的面向对象开发（Object Oriented Programming，简称OOP），习惯了传统软件模式的开发者需要适应一下。 

基于组件的基本思路是：使用GameObject作为基础框架，但GameObject并不提供任何实际功能，所有功能全部由组件（派生于MonoBehaviour的各种类）实现，并能够任意插接到GameObject上，通过代码或编辑器操作均可。这样，GameObject就成为一系列组件的集合，能够完成各种复杂的功能。组件内部提供一系列预先定制的流程和接口，开发者可以在其中各个环节中添加各种逻辑，当组件插入到GameObject之后，会由GameObject统一调度这些流程和接口。

GameObject并不能独立存在，必须将其放入场景（Scene）中，GameObject才拥有生命周期，也就是说，GameObject是依赖于场景而存在的。事实上，GameObject在创建时就会被Unity自动放入当前激活的场景之中。不过，Unity提供一种预设体（Prefab）的机制，允许使用者将一个编辑好的GameObject存储下来，之后可以用拖拽的方式放入任何场景，使得GameObject成为可复用的预设元件。

Unity支持C#、JavaScript和Boo三种语言编写，但C#效率最高，结构性也最好，因此官方推荐使用C#进行开发。

## 为什么推荐Unity？

### 易于开发

Unity最初的设计方向是一款3D编辑器，工程并不完全由代码实现，更多是在场景中编辑物体，其目的就是希望能让更多非技术出身的Designer可以使用。也因此，Unity的程序主要沿用的是脚本语言编程，除了C#之外还支持JavaScript和Boo，一些简单的功能只需要设置物体，添加一点脚本即可实现，这一点同Flash比较接近。当然，想要真正做出好的应用，还是需具备扎实的程序功底的开发人员参与，但不可否认，Unity这样的工具给更多开发者提供了很好的发挥平台。 

### 完善的工具链

正如刚才所说，Unity的设计初衷就是一款3D编辑器，因此它可以说是先有工具后有引擎，工具链方面会有优势。涉及3D开发的方方面面都有便捷的功能，从基础的物体、光照模型、物理系统、粒子系统，到更高级的动画编辑器、动作状态机、寻路网格、反向动力学等等，大都可以用拖拽加配置参数的方式进行编辑。事实上，仅使用Unity内置的功能，就足以迅速做出一系列可执行复杂功能的Demo，这也使设计师可以最快的创造出产品原型，快速验证思路，找到不足并加以改进。

Unity还提供强大的编辑器扩展功能，使用者可以很容易的自己做出针对自定义数据和功能的编辑器。工欲善其事，必先利其器，这句老话在Unity的设计理念中得到了很好的体现。

### 优秀的跨平台特性

因为Unity选择开源的Mono框架——可以横跨各种平台，不受制于任何平台的限制，这使得Unity从开发到发布应用都具有良好的跨平台性。

Unity能够针对许多平台发布产品，除了主流的PC、Mac、iOS、Android之外，还包括UWP、XBOX、PS3/4、WebGL、甚至包括一些智能电视。 

### ASSETSTORE带来的扩展性

Unity的另一个备受称道的特性，就是AssetStore。简单的说，任何用Unity开发的模块，都可以简单的打包成Package，只要你有Unity账号，就可以放到AssetStore上，开出价格供大家随意购买。

这个设计对双方都有好处。对于购买者来说，很多已经比较成型的模块，小到一个JSON工具、一个Tween脚本，大到全套的复杂地形寻路解决方案，或者第一人称视角摄像机跟随方案，都能在AssetStore里找到。

AssetStore搜索是否有现成的解决方案使用，往往能更快的产生原型，节省大量的开发和试错的时间。 