# 排序算法

## 插入排序

基本思想：将待排序表看成是左右两部分，其中左边为有序区，右边为无序区，整个排序过程就是将右边无序区的元素插入到左边有序区中，以构成新的有序区。

### 直接插入排序

1. 搜索插入的位置
2. 移动元素以腾出空位
3. 插入元素

### 希尔排序

1. 将待排序的序列分为若干组，可以在每组内进行直接插入如排序
2. 待每组排序完毕后再对整个序列进行插入排序

## 交换算法

### 快速排序

基本思想：给定一向量区域S[lo,hi),对于任何lo<=mi<hi，以元素S[mi]为界，分割出子向量S[lo,mi)和S(mi,hi)。若S[lo,mi)中的元素均不大于S[mi]，且S(mi,hi)中的元素均不小于S[mi]，则S[mi]为向量S的一个轴点(pivot)，然后采用分治策略，递归利用轴点的特点，便可完成整体的排序。

```c++
void quickSort(vector<int>& S, int lo,int hi)
{
    if(hi-lo<2) return ;
    int mi = partition(S,lo, hi-1);
    quickSort(S,lo,mi);
    quickSort(S,mi+1,hi);
}

int partition(vector<int> S，int lo, int hi)
{
	std::swap(s[lo],S[rand()%(hi-lo+1)+lo]);
	int pivot = S[lo];
	while(lo<hi)
	{
        while(lo<hi)
        {
            if(S[hi]>pivot)
            	hi--;
            else
            {	S[lo++] = S[hi]; break;}
        }
        while(lo<hi)
        {
            if(S[lo]<pivot)
                lo++;
            else
            {
                S[hi--] = S[lo]; break;
            }
        }
	}//assert: lo=hi
    S[lo] = pivot;
    return lo;
}
```



### 冒泡排序



## 选择排序

### 堆排序

根据元素的排列方式，分为max-heap和min-heap.

max-heap:每个节点的键值都大于或等于其子节点键值。

min-heap:每个节点的键值都小于或等于其子节点键值。

**STL中使用的为max_heap**.其对应算法如下

**push_heap算法**：1. 新加入的元素一定要放在最下一层最右边作为叶节点。2. 将新节点与父节点比较，如果key比父节点大，则父子对换位置，如此一致上溯，知道不需要对换或直到根节点为止。

**pop_heap算法**: 1. pop根节点留下空节点，然后割舍最下一层最右边的叶节点。2. 将空节点和其较大子节点对换，并持续下溯，直至叶节点为止，然后将割舍的叶节点放入空节点。再对其执行一次上溯即可。

## 归并排序







# 高级搜索树

## 伸展树（splay tree）

相对于AVL树，伸展树也是平衡二叉搜索树的一种形式。

常见伸展树：

1. 简易伸展树:每访问过一个节点后，即反复以它的父节点为轴，经过适当选择将其提升一层，直至最终成为树根。
2. 双层伸展树：将逐层伸展改为双层伸展。每次通过当前节点v向上追溯两层，并根据父节点和祖父节点的位置进行相应旋转。

特点：

- 无需记录节点高度或平衡因子;编程实现简单易行——优于AVL树

  分摊复杂度O(logn)——与AVL树相当

- 局部性强，缓存命中率极高(即k<< n<< m)

  > 对于一棵节点为n的伸展树，假设经常操作的节点为k，则由于“双层伸展调节”的特性，使得伸展树的k个节点集中在根节点处，从而提高了这k个节点的命中率。
  >
  > 通常操作系统会利用这点，使缓存利用率尽可能提高。这就是为什么新电脑再使用一段时间后更顺手。

  ​	效率甚至可以更高——自适应的O(logk)

  ​	任何连续的m次查找，都可以在O(mlogk +nlogn)时间内完成。（在达到logk之前，需要达到常规的n次操作，每次是logn。）

- 仍不能保证的单次最坏情况的出现，不适用于对效率敏感的场合。

  >  比如在手术室里，控制手术器械的程序，绝不能使用伸展树这类数据结构

  伸展树时间复杂度的严格证明参考:邓俊辉数据结构习题8-2.



## B-树(B tree) 

平衡的多路搜索树.（Banlanced Multiway Search Trees ）

- 所谓m阶B-树，即m路平衡搜索树(m>=2)，

- B-树结构适用于在相对更小的内存中，实现对大规模数据的高效操作。其原因是将活跃的B树根节点常驻于内存，而其他大数据集存放于外存，只载入必需的节点，尽可能减少I/O操作。(实现上通过指向外部节点的引用实现, **不同存储级别的串接**)

- m阶的B-树内部节点中

  关键码n: n<=m-1,则有n+1个分支。

  树根：2<= n+1,(至少两个分支)

  内部节点的分支数n+1,  ceil(m/2)<= n+1<=m . 

- 故称为
  $$
  (\left \lceil m/2 \right \rceil,m) 树
  $$








- 所有**叶节点**的深度统一相等。但B树中定义了一种外部节点（即叶节点中数值为空且并不存在的孩子）

		如下图，4阶B树，高度为3，其中每个节点包含1~3个关键码，拥有2~4个分支。

		(a)最基础表示——>(b)关键码保留，将引用转化为一个点——>(c)省略掉外部节点.

![B-tree.png](https://github.com/Realee007/jobbook/blob/master/src/image/B-tree.png?raw=true) 


- 定义：节点可以用向量vector表示，同一节点的所有孩子组织为一个向量，孩子向量的实际长度比关键码向量多一。（为了与I/O操作的延迟相匹配，**每个节点的大小**应该尽可能设计为与**一次I/O兑换的页面相匹配(200~300)**。）

- 操作：查找，基于vector顺序查找，若某层查找失败，则沿着引用不断深入下一层（每一次的深入可以看成，将节点载入到内存），直至某一关键码命中（成功），或到达某一个外部节点（no1,no.2）。 no1. 查找失败，2. 这个外部引用存放的是一个更低层次级别的B树（看成不同存储级别的B树串接）

- 动态操作步骤

  **查找**：对于N个关键码的m阶B-树，耗时不超过O(logmN)

  **插入**：相对复杂，首先是查找该关键码至某一外部节点v，且其父节点必然为某一节点p。于是在该p中查找并确定插入的位置r.如果插入的过程中该节点出现**上溢**，则以中位数为界进行分裂，并将中位数上身一层，并以分裂的子节点作为左右孩子，极端情况是分裂到根，导致**B-树长高**。 耗时不超过O(logmN)

  删除:更复杂，首先也是查找，但是删除某关键码会导致该节点的关键码总数过少(小于ceil(m/2)-1),则发生**下溢**。左顾右盼兄弟节点，向其借关键码或合并，在进行合并操作可能导致父节点下溢，这种操作会不断向根节点蔓延直到树根，若合并后根的关键码为空，导致**B-树降低**。耗时不超过O(logmN)

- 水平操作: 内存操作:RAM， 垂直操作:Disk。



1. 作用：B树的动机实现高效的I/O。

> 对于典型的计算机模型，自上而下CPU<——>RAM<——>DISK<——>ARRAY... 相对任何一个存储级别，如果希望**向更低**的存储级别**写入**或**从更低**的存储级别**读入**数据。我们称之为输出和输入，简称I/O。
>
> 对于上层存储器而言，对底层存储器的访问都称为**外存访问**。
>
> 以磁盘和内存为例，两者访问速度是ms与ns之差(10^5)。

2. 相对比AVL：

B-tree多层考察，即将父子节点合并为超级节点。每n代合并, 类比于二路搜索路，每个超级节点有m = 2^d路分支。m-1个关键码。

多级存储系统使用B-树，可针对外部查找，大大减少I/O次数。

相比**AVL**树，如果有n = 1G个记录，每次查找需要log(2,10^9) = **30 次I/O**操作，每次只能读**一个**关键码.

而B树，由于充分利用外存对**批量访问**的高效支持，将此**特点**转化为优点。每下降一层，都以**超级节点**为单位，读入**一组**关键码。

具体多大一组？取决于磁盘数据卡的大小.比如目前多数数据卡采用m = 200~300.

假如m = 256,则**B树**每次查找只需要log(256,10^9) <= **4次I/O**

3. 相比红黑树

   红黑树和4阶B-树关系紧密。 将红黑树进行提升变化，可以将其等价为4阶B-树。



## B+树(B plus Tree)

B+树是B-树的一种变形。有着比B-树更高的性能。

相比B树有相同的特点，但是在B+树中

内部节点只存储index(not elements)和pointer.

**外部节点才存储data**.并且外部节点通过**双向链表**连接。好处是对于范围查询，在查找的过程中不需要从根开始，而是根据双向链表直接查找，节省查找时间。

![BplusTree.png](https://github.com/Realee007/jobbook/blob/master/src/image/BplusTree.png?raw=true) 



## 红黑树(RB tree)

**RB-tree(红黑树),**任何动态操作引发的结构变化量不至超过O(1)

建立在AVL树的基础上:

由红、黑两类节点组成的BST(统一增设外部节点NULL，使之成为真二叉树)

1. 树根：必为黑色

2. 外部节点：均为黑色

3. 其余节点，若为红，则只能有黑孩子 (红之子、之父比黑 )

4. 外部节点到根：途中黑节点数目相等 (黑深度)

   如下图，所画出来的为假想的外部节点.

   ![RB-tree.png](https://github.com/Realee007/jobbook/blob/master/src/image/RB-tree.png?raw=true)

   如果通过提升变化，可以将红黑树转换为4阶B-树. 

   具体地，自顶而下逐层考查红黑树各节点，每遇到一个红节点，都将对应的子树整体提升一层，从而与其父节点（必黑）水平对齐，二者之间的联边则相应调整为横向，由于考虑到条件(3)，同向者彼此不会相邻，所以涉及的节点至多3个，即构成4阶B-树的一个超级节点。

### AVL树

平衡二叉搜索树**(AVL树）**：在BST的基础上，要求任何节点的**左右子树高度**相**差**最多**1**。（重平衡的操作包括单旋和双旋，有一种统一的处理方法3+4重构）

**二叉搜索树(BST)**： 任何节点的键值一定大于左子树的每一个节点的键值，并小于其右子树的每一个节点的键值(键值key可能和实值value相同也可能不同)。

插入：从根节点开始，遇键值大就向左，键值小就向右，一直到尾端。

删除：如果删除点A只有一个子节点，就直接把A的子节点连至A的父节点；如果A有两个子节点，我们就以右子树内最小节点取代A。

