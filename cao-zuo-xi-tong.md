# 操作系统

## 函数可重入与线程安全

函数可重入(Reentrant)：一个函数被重入，表示这个函数没有执行完成，由于外部因素或内部调用，又一次进入该函数执行。

一个函数要被重入，只有两种情况:

1. 多个线程同时执行这个函数。
2. 函数自身（可能是经过多层调用后）调用自身。

一个函数被称为可重入的，表明该函数被重入之后不会产生任何不良后果。如：

```c++
int sqr(int x)
{	return x*x; }
```

 可重入函数的特点：

- 不适用任何（局部）静态或全局的非const变量。

- 不返回任何（局部）静态或全局的非const变量的指针。

- 仅依赖任何单个资源的锁

- 不调用任何不可重入的函数。

  **可重入是并发安全的强力保障**，一个可重入的函数可以在多线程环境下放心的使用。

  参考：https://blog.csdn.net/acs713/article/details/20034511



## 进程和线程的区别

**进程(process)**：

- 是执行中的程序。

- 进程包括程序代码(文本段)、当前状态（由程序计数器的值和处理器寄存器的内容表示）、堆栈段、堆和数据段。

- 当前状态包括：1. 新的；2. 运行；3. 等待；4.就绪；5. 终止。

- 在操作系统中，每个进程用进程控制块(PCB)表示。

- PCB包含

  ​	1. 进程ID； 2. 进程状态；3. 程序计数器；4. CPU寄存器；5. CPU调度信息...

**线程(thread)**:

- 是CPU使用的基本单元。
- 由线程ID、程序计数器、寄存器集合和栈组成。 
- 它与属于同一进程的其他线程共占代码段、数据段、其他系统资源，独占寄存器和栈。



## 进程调度

### 调度队列

进程调度选择一个可用的进程到CPU上执行。

进程进入系统后，会被加到**作业队列**(job queue)。而驻留在内存中就绪(ready)、等待运行(wait)的进程保存在**就绪队列**(ready queue)，还有等待特定I/O设备的进程放在**设备队列**(devic queue)。

进程的选择是由相应的**调度程序**(scheduler):

-  长期调度程序，从大容量（磁盘）的缓冲池中选择进程并装入内存。

- 短期调度程序，从准备执行的进程中选择进程并为之分配CPU。

### 上下文切换≈ 进程切换

上下文切换(context switch) 

具体操作：

1. 保存旧进程的状态到其PCB中。

2. 装入经调度要执行新进程的上下文。

   ![context switch.png](https://github.com/Realee007/jobbook/blob/master/src/image/context%20switch.png?raw=true) 



## 进程间的通信

进程间的相互协作，来交换数据与信息，通过进程通信:

进程的通信方式 IPC(InterProcess Communication)

1. 消息传递(message passing)：在协作进程间交换消息实现通信，进程P和Q通信，首先需要有通讯线。逻辑实现路线和send()/receive()操作的方法：

   - 直接或间接通信。

     1. 对于直接通信，需要每个进程必须明确地命名通信的接收者或发送者。

        send(P,message)：发送消息给P,  receive(Q,message)：收到进程Q的消息。

     2. 间接通信

        通过邮箱或者端口来发送个接收消息。邮箱可以抽象成一个对象，进程可以向其中存放、删除消息。

        send(A,message)：发送一个消息到邮箱A， receive(A,message)：接收来自邮箱A的消息。

   - 同步或异步通讯。

     同步也称为阻塞，异步称为非阻塞

     1. 阻塞send：发送进程阻塞，直到消息被（接收进程或邮箱）接收。
     2. 非阻塞send：发送进程发送消息并再继续操作。
     3. 阻塞receive：接受者阻塞，直到有消息可用。
     4. 非阻塞receive：接受者收到一个有效消息或空消息。

   - 自动或零缓冲。

     通信进程所交换的消息都驻留在临时队列。

     队列的三种实现：

     1. 零容量，阻塞send。
     2. 有限容量，如果队列未满，则非阻塞send，当容量满后，必须阻塞send，直到容量可用。
     3. 无线容量，非阻塞send。




2. 共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是**最快的IPC方式**，它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。 

   ​	常见：生产者进程--消费者进程，采用共享内存（缓存）。

3. 管道（Pipes）：

   >A *pipe* is a section of shared memory that processes use for communication.  ---[MSDN--pipes](https://docs.microsoft.com/zh-cn/windows/desktop/ipc/pipes)

   管道是共享内存的一种。创建管道的进程称为pipe server, 与管道连接的进程称为pipe client. 进程A向pipe中写入信息，其他进程从pipe中读取信息。

   1. 匿名管道（anonymous-pipes）:

      匿名，单向管道(单工)，通常建立在父进程和子进程之间的通信，匿名管道总是本地的; 不能用于通过网络进行通信。 

   2. 命名管道（named pipes）:

      遵循FIFO ，任何进程都可以充当服务器和客户端，从而可以对等通信（半双工），可用于在同一计算机上的进程之间或跨网络的不同计算机上的进程之间提供通信。

      

4. 套接字（socket）：数据通过网络接口（IP地址和端口 ）发送到同一台计算机上的不同进程或网络上的另一台计算机。TCP/UDP。



## 线程间的通信机制 

线程间通信的主要目的是用于**线程同步**，所以**线程没有进程通信**中用于**数据交换**的通信机制。 

1. 锁机制
     1. 互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。 
     2. 读写锁：允许多个线程同时读共享数据，而对写操作互斥。
     3. 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 
2. 信号量机制：包括无名线程信号量与有名线程信号量
3. 信号机制：类似进程间的信号处理。

## 进程中断

进程的中断是归类于**异常**。在进程运行的过程中，处理器检测到事件（event），并确定异常号，随后触发异常，转到相应的处理程序。异常表的起始地址放在**异常表基址寄存器**（特殊CPU寄存器）。

具体的异常分为四类：

| 类别 | 原因              | 异步/同步 | 返回行为           |
| ---- | ----------------- | --------- | ------------------ |
| 中断 | 来自I/O设备的信号 | 异步      | 返回下一条指令     |
| 陷阱 | 有意的异常        | 同步      | 返回下一条指令     |
| 故障 | 潜在可恢复的错误  | 同步      | 可能返回到当前指令 |
| 终止 | 不可恢复的错误    | 同步      | 不会返回           |

异常的异步和同步理解：

中断有两种，一种是CPU本身在执行程序的过程中产生的，一种是由CPU外部产生的。

1. 外部中断，就是通常所讲的“中断”（interrupt）。对于执行程序来说，这种“中断”的发生完全是异步的，因为不知道什么时候会发生。CPU对其的响应也完全是被动的，可以通过“关中断”指令关闭对其的响应。  
2. 由软件产生的中断一般是由专设的指令，如X86中的“INT n”在程序中有意产生的是主动的，同步的。只要CPU执行一条INT指令，在开始执行下一条指令之前一定会进入中  断服务程序。这种主动的中断称故障指令。  

## 进程饥饿 

在操作系统中，多个进程同时运行时，系统需要确定一个资源分配策略给进程，以提高计算机的吞吐量。如CPU调度，有些**调度是不公平的**，如优先级调度算法。某些已就绪的进程因长时间的等待CPU从而发送**饥饿（无期限的阻塞）**。

实例： 多个thread阻塞在同一个mutex上，系统调度器会选择其中一个接触阻塞状态，而选择的方式有可能造成某个不幸的thread永远也不会解除阻塞进入运行状态。

 低优先级进程的饥饿的解决方法之一是**老化（aging）**，即逐渐增加在系统中等待很长时间的进程的优先级。

## 线程池

线程池是在进程开始时，创建一定数量的线程，并放入到池中以等待工作，当服务器收到请求时会唤醒池中的线程（如果可用的话），并将要处理的请求传递给它。一旦完成了服务，它会返回到池中再等待。如果池中没有可用的线程，那么服务器会一直等待直到有空线程为止。

C++封装线程池

https://blog.csdn.net/gavingreenson/article/details/72770818



对象池用来通常用来避免重复的内存分配和销毁及内存碎片的产生.

适用的情况如下：

1. 当你需要频繁地创建和销毁对象时
2. 对象的大小类似
3. 堆内存的分配有可能造成内存碎片时
4. 每个对象有封装一些自己的资源类似数据库或网络连接，很难获取及复用

https://blog.csdn.net/l773575310/article/details/71601460(unity3d 飞机子弹模型)



## 部分词语解释

## 并发和并行区别

并发是两个队列交替使用一台咖啡机，并行是两个队列同时使用两台咖啡机。

并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）cpu执行，如果可以就说明是并行，而并发是多个线程被（一个）cpu 轮流切换着执行。