# 排序算法

## 交换算法

### 快速排序

### 归并排序







# 高级搜索树

## AVL树 



## 红黑树(RB tree)



## 伸展树（splay tree）

特点：

- 无需记录节点高度或平衡因子;编程实现简单易行——优于AVL树

  分摊复杂度O(logn)——与AVL树相当

- 局部性强，缓存命中率极高(即k<< n<< m)

  > 对于一棵节点为n的伸展树，假设经常操作的节点为k，则由于“双层伸展调节”的特性，使得伸展树的k个节点集中在根节点处，从而提高了这k个节点的命中率。
  >
  > 通常操作系统会利用这点，使缓存利用率尽可能提高。这就是为什么新电脑再使用一段时间后更顺手。

  ​	效率甚至可以更高——自适应的O(logk)

  ​	任何连续的m次查找，都可以在O(mlogk +nlogn)时间内完成。（在达到logk之前，需要达到常规的n次操作，每次是logn。）

- 仍不能保证的单次最坏情况的出现，不适用于对效率敏感的场合。

  >  比如在手术室里，控制手术器械的程序，绝不能使用伸展树这类数据结构

  伸展树时间复杂度的严格证明参考:邓俊辉数据结构习题8-2.

## B树(B tree) 

B树的动机实现高效的I/O。

> 对于典型的计算机模型，自上而下CPU<——>RAM<——>DISK<——>ARRAY... 相对任何一个存储级别，如果希望**向更低**的存储级别**写入**或**从更低**的存储级别**读入**数据。我们称之为输出和输入，简称I/O。
>
> 对于上层存储器而言，对底层存储器的访问都称为**外存访问**。
>
> 以磁盘和内存为例，两者访问速度是ms与ns之差(10^5)。



> 640k ought to be enough for anybody
>
> --- B.Gates, 1981



特点：



## B+树



## B树 vs B+树



B-树就是B树。

数据库以B树格式储存，只解决了按照"主键"查找数据的问题。如果想查找其他字段，就需要建立索引（index）。 

https://blog.csdn.net/v_JULY_v/article/details/6530142/