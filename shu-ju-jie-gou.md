[TOC]



# 排序算法

## 稳定排序

大小相同的值再排序完后，相对位置仍然保持不变。

### 1. 归并排序

> 所谓归并，即将两个已有序的序列合并成一个序列。可以用如下例子解释：
>
> 设序列A={a1,a2,...,am}和B={b1,b2,...,bn}为非降序，先将A和B合并为一个非降序C={c1,c2,...,cm+n}。
>
> 1. C序列中的第一个元素c1从a1或者b1中选取，判断ai和bj的大小，然后将其中小的放入C序列中。
>
> 2. 当1操作完后，如果其中有一个序列不为空，则将其全添加至C序列尾部。
>
>    时间复杂度:O(n+m)。

- 基本思想：基于归并方法，将包含n个数据的序列看成n个有序子序列，长度为1，然后两两归并，得到n/2个长度为2的有序子序列，然后两两归并，以此类推。直到得到1个长度为n有序序列。

- 非原地算法（Out-place algorithm），因为顺序序列无法就地归并，需要额外一个O(n)辅助空间。
- 时间复杂度：O(nlog2n)  ，因为每一次合并两序列，时间为O(n+m)，然后总共需要log2n趟归并。故总的为O(nlog2n)

- 应用：

  	排序10G大数据，先在各个主机内部排序，再用归并将各个主机排好的数据汇总，在归并排序时使用缓冲区（使用Iterable接口）缓冲归并和读取数据之间的速度差异。

### 2. 冒泡排序

- 基本思想：从序列一端开始，逐个比较相邻的两个元素，发现倒序则交换。

  （从小到大）典型做法是从后往前，遍历一次，一定能将其中最小的交换到最终位置。

- 原地算法

- 时间复杂度O(n^2)

### 3. 插入排序

包括：

1. 直接插入排序
2. 二分插入排序(折半插入排序)
3. 希尔排序

#### 1.直接插入排序

>49, 60, 71
>
>将待排序第4个记录(11)插入，设置监视哨vec[0]=11，然后从71从右往左查找，11小于71，将71右移一个位置，直到11>=vec[0],它的插入位置为vec[1].即 11, 49, 60, 71

- 基本思想：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止。


#### 2.二分插入排序

- 基本思想：把待排序的记录按其关键码的大小，以二分法查找，插入到一个排好序的有序序列中，直到所有记录插入完毕。 
- In-place排序。
- 时间复杂度为O(n^2)，二分查找的排序比较次数为log2n.

### 4. 基数排序

>假设一序列{73, 22, 93, 43, 55, 14, 28, 65, 39, 81 }
>
>首先根据个位数字将其分配到0-9个桶中
>
>| 0    | 1    | 2    | 3         | 4    | 5     | 6    | 7    | 8    | 9    |
>| ---- | ---- | ---- | --------- | ---- | ----- | ---- | ---- | ---- | ---- |
>|      | 81   | 22   | 73, 93,43 | 14   | 55,65 |      |      | 28   | 29   |
>
>接下来将这些桶子中的数值重新串接起来，成为以下的数列：
>
>81, 22, 73, 93, 43, 14, 55, 65, 28, 39
>
>再进行一次分配，这次是根据十位数来分配：
>
> 
>
>| 0    | 1    | 2      | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
>| ---- | ---- | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
>|      | 14   | 22，28 | 39   | 43   | 55   | 65   | 73   | 81   | 93   |
>
>接下来将这些桶子中的数值重新串接起来，成为以下的数列：
>
>14, 22, 28, 39, 43, 55, 65, 73, 81, 93。 即排序成功。
>
>上述排序方法为：最低位优先(Least Significant Digit first)法，简称LSD法 ，理所当然，存在最高位优先(Most Significant Digit first)法，简称MSD法 。
>
>LSD适用于位数小的数列。

- 时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数 。



## 不稳定排序

### 5. 快速排序

- 基本思想：给定一向量区域S[lo,hi),对于任何lo<=mi<hi，以元素S[mi]为界，分割出子向量S[lo,mi)和S(mi,hi)。若S[lo,mi)中的元素均不大于S[mi]，且S(mi,hi)中的元素均不小于S[mi]，则S[mi]为向量S的一个轴点(pivot)，然后采用分治策略，递归利用轴点的特点，便可完成整体的排序。
- 原地算法

```c++
void quickSort(vector<int>& S, int lo,int hi)
{
    if(hi-lo<2) return ;
    int mi = partition(S,lo, hi-1);
    quickSort(S,lo,mi);
    quickSort(S,mi+1,hi);
}

int partition(vector<int> S，int lo, int hi)
{
	std::swap(s[lo],S[rand()%(hi-lo+1)+lo]);
	int pivot = S[lo];
	while(lo<hi)
	{
        while(lo<hi)
        {
            if(S[hi]>pivot)
            	hi--;
            else
            {	S[lo++] = S[hi]; break;}
        }
        while(lo<hi)
        {
            if(S[lo]<pivot)
                lo++;
            else
            {
                S[hi--] = S[lo]; break;
            }
        }
	}//assert: lo=hi
    S[lo] = pivot;
    return lo;
}
```

### 6. 选择排序

- 基本思想：（若是从小到大排序）在n个数据中，每次一趟在n-i+1(i=1,2,3....,n-1)个数据中选取最小的数据与第i个交换，并将其作为有序序列的第i个记录。
- 原地算法(In -place algorithm)
- 不稳定算法
- 时间复杂度为：O(n^2)，空间复杂度：O(1)

### 7. 堆排序

- 基本思想：利用堆这种特殊的数据结构所设计的排序算法。该模型为完全二叉树并每个节点满足为max-heap或min-heap的特点。

  1. max-heap:每个节点的键值都大于或等于其子节点键值。

  2. min-heap:每个节点的键值都小于或等于其子节点键值。

- 通常堆通过vector来实现，在vector的起始位置为0情况下:

  -  父节点i的左孩子节点在位置(2*i+1)；
  - 父节点i的右孩子节点在位置(2*i+2)；
  - 孩子节点i的父节点在位置floor( (i-1)/2 )；(floor地板：向下取整)

- **STL中使用的为max_heap**.其对应算法如下：

  **push_heap算法**：

  1. 新加入的元素一定要放在最下一层最右边作为叶节点。

  2. 将新节点与父节点比较，如果key比父节点大，则父子对换位置，如此一致上溯，知道不需要对换或直到根节点为止。

  **pop_heap算法**: 

  1. pop根节点留下空节点，然后割舍最下一层最右边的叶节点。
  2. 将空节点和其较大子节点对换，并持续下溯，直至叶节点为止，然后将割舍的叶节点放入空节点。再对其执行一次上溯即可。

### 8. 希尔排序

之前提到过是插入排序的另一种更高效的改进版。基于以下两点进行了改进：

1. 插入排序对已排好序的数据操作时，效率最高，即线性排序。
2. 插入排序低效的原因是插入排序每次只能将数据移动一位。

>举个例子： 一组数据{13 ,14 ,94 ,33 ,82 ,25 ,59 ,94 ,65 ,23 ,45 ,27 ,73 ,25 ,39 ,10};
>
>如果我们以步长为5开始进行排序而不是i++，将这个数组放在5列的表中。如下：
>
>13，14，94，33，82
>
>25，59，94，65，23
>
>45，27，73，25，39
>
>10
>
>然后对每列进行排序：
>
>10，14，73，25，23
>
>13，27，94，33，39
>
>25，59，94，65，82
>
>45
>
>[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]，这时10已经在正确的位置，然后再以2（5/2）步长进行排序：
>
>10， 14
>
>73， 25
>
>23， 13
>
>27， 94
>
>33， 39
>
>25， 59
>
>94， 65
>
>82， 45
>
>然后再以1步长，此时就是简单排序。

- 时间复杂度O(nlog^2 n)

##  排序算法总结


![sort algorithm.png](https://github.com/Realee007/jobbook/blob/master/src/image/sort%20algorithm.png?raw=true) 



# 容器类的操作

## 支持[]操作的容器

vector:	随机访问迭代器,复杂度O（1）

deque:(底层为vector) 同上

map：双向迭代器，不过由于是关联容器，需要通过key访问alue的方法，O（h），h为红黑树的高度 

unordered_map：前向迭代器，同上，平摊复杂度O（1），最差O（n），也与散列函数的好坏有关。

	当通过[]访问map及unordered_map时，如果元素不存在，则新建元素放入map中。

string：同vector



# 树

节点度：该节点 的子节点个数 。

树的度：节点度最大值就是该树的度  。

节点v的深度：指从根节点出发到达v的唯一通路所经过边的数目，记为:depth(v)，其中根节点的深度为0。（深度为k的节点,至多2^k个）

树的高度：所有**叶子**节点**深度最大**者，称为树的高度。（含n个节点、高度为h的**二叉树**中 `h<n<2^(h+1)`） ； 特别规定空树的高度为-1.仅含单个节点的树高度为0.

子树的高度：子树根节点的高度。

height(v)+depth(v)<=height(root).

![Tree-1.png](https://github.com/Realee007/jobbook/blob/master/src/image/Tree-1.png?raw=true) 





二叉树的性质：

1. 在二叉树的第i(i>=1)层最多有2^(i-1)个节点。
2. 深度为k(k>=0)的二叉树最少有k个节点，最多有2^k -1 个节点。
3. 对于任一棵非空二叉树，若其叶子节点数为n0，度为2的节点数为n2，则n0 = n2+1.
4. 具有n个节点的完全二叉树的深度为`ceil (log2 n)+1`
5. 



# 高级搜索树

## 伸展树（splay tree）

相对于AVL树，伸展树也是平衡二叉搜索树的一种形式。

常见伸展树：

1. 简易伸展树:每访问过一个节点后，即反复以它的父节点为轴，经过适当选择将其提升一层，直至最终成为树根。
2. 双层伸展树：将逐层伸展改为双层伸展。每次通过当前节点v向上追溯两层，并根据父节点和祖父节点的位置进行相应旋转。

特点：

- 无需记录节点高度或平衡因子;编程实现简单易行——优于AVL树

  分摊复杂度O(logn)——与AVL树相当

- 局部性强，缓存命中率极高(即k<< n<< m)

  > 对于一棵节点为n的伸展树，假设经常操作的节点为k，则由于“双层伸展调节”的特性，使得伸展树的k个节点集中在根节点处，从而提高了这k个节点的命中率。
  >
  > 通常操作系统会利用这点，使缓存利用率尽可能提高。这就是为什么新电脑再使用一段时间后更顺手。

  效率甚至可以更高——自适应的O(logk)

  任何连续的m次查找，都可以在O(mlogk +nlogn)时间内完成。（在达到logk之前，需要达到常规的n次操作，每次是logn。）

- 仍不能保证的单次最坏情况的出现，不适用于对效率敏感的场合。

  >  比如在手术室里，控制手术器械的程序，绝不能使用伸展树这类数据结构

  伸展树时间复杂度的严格证明参考:邓俊辉数据结构习题8-2.



## B-树(B tree) 

平衡的多路搜索树.（Banlanced Multiway Search Trees ）

- 所谓m阶B-树，即m路平衡搜索树(m>=2)，

- B-树结构适用于在相对更小的内存中，实现对大规模数据的高效操作。其原因是将活跃的B树根节点常驻于内存，而其他大数据集存放于外存，只载入必需的节点，尽可能减少I/O操作。(实现上通过指向外部节点的引用实现, **不同存储级别的串接**)

- m阶的B-树内部节点中

  关键码n: n<=m-1,则有n+1个分支。

  树根：2<= n+1,(至少两个分支)

  内部节点的分支数n+1,  ceil(m/2)<= n+1<=m . 

- 故称为
  $$
  (\left \lceil m/2 \right \rceil,m) 树
  $$




















- 所有**叶节点**的深度统一相等。但B树中定义了一种外部节点（即叶节点中数值为空且并不存在的孩子）

		如下图，4阶B树，高度为3，其中每个节点包含1~3个关键码，拥有2~4个分支。

		(a)最基础表示——>(b)关键码保留，将引用转化为一个点——>(c)省略掉外部节点.

![B-tree.png](https://github.com/Realee007/jobbook/blob/master/src/image/B-tree.png?raw=true) 


- 定义：节点可以用向量vector表示，同一节点的所有孩子组织为一个向量，孩子向量的实际长度比关键码向量多一。（为了与I/O操作的延迟相匹配，**每个节点的大小**应该尽可能设计为与**一次I/O兑换的页面相匹配(200~300)**。）

- 操作：查找，基于vector顺序查找，若某层查找失败，则沿着引用不断深入下一层（每一次的深入可以看成，将节点载入到内存），直至某一关键码命中（成功），或到达某一个外部节点（no1,no.2）。 no1. 查找失败，2. 这个外部引用存放的是一个更低层次级别的B树（看成不同存储级别的B树串接）

- 动态操作步骤

  **查找**：对于N个关键码的m阶B-树，耗时不超过O(logmN)

  **插入**：相对复杂，首先是查找该关键码至某一外部节点v，且其父节点必然为某一节点p。于是在该p中查找并确定插入的位置r.如果插入的过程中该节点出现**上溢**，则以中位数为界进行分裂，并将中位数上身一层，并以分裂的子节点作为左右孩子，极端情况是分裂到根，导致**B-树长高**。 耗时不超过O(logmN)

  删除:更复杂，首先也是查找，但是删除某关键码会导致该节点的关键码总数过少(小于ceil(m/2)-1),则发生**下溢**。左顾右盼兄弟节点，向其借关键码或合并，在进行合并操作可能导致父节点下溢，这种操作会不断向根节点蔓延直到树根，若合并后根的关键码为空，导致**B-树降低**。耗时不超过O(logmN)

- 水平操作: 内存操作:RAM， 垂直操作:Disk。



1. 作用：B树的动机实现高效的I/O。

> 对于典型的计算机模型，自上而下CPU<——>RAM<——>DISK<——>ARRAY... 相对任何一个存储级别，如果希望**向更低**的存储级别**写入**或**从更低**的存储级别**读入**数据。我们称之为输出和输入，简称I/O。
>
> 对于上层存储器而言，对底层存储器的访问都称为**外存访问**。
>
> 以磁盘和内存为例，两者访问速度是ms与ns之差(10^5)。

2. 相对比AVL：

B-tree多层考察，即将父子节点合并为超级节点。每n代合并, 类比于二路搜索路，每个超级节点有m = 2^d路分支。m-1个关键码。

多级存储系统使用B-树，可针对外部查找，大大减少I/O次数。

相比**AVL**树，如果有n = 1G个记录，每次查找需要log(2,10^9) = **30 次I/O**操作，每次只能读**一个**关键码.

而B树，由于充分利用外存对**批量访问**的高效支持，将此**特点**转化为优点。每下降一层，都以**超级节点**为单位，读入**一组**关键码。

具体多大一组？取决于磁盘数据卡的大小.比如目前多数数据卡采用m = 200~300.

假如m = 256,则**B树**每次查找只需要log(256,10^9) <= **4次I/O**

3. 相比红黑树

   红黑树和4阶B-树关系紧密。 将红黑树进行提升变化，可以将其等价为4阶B-树。



## B+树(B plus Tree)

B+树是B-树的一种变形。有着比B-树更高的性能。

相比B树有相同的特点，但是在B+树中

内部节点只存储index(not elements)和pointer.

**外部节点才存储data**.并且外部节点通过**双向链表**连接。好处是对于范围查询，在查找的过程中不需要从根开始，而是根据双向链表直接查找，节省查找时间。

![BplusTree.png](https://github.com/Realee007/jobbook/blob/master/src/image/BplusTree.png?raw=true) 



## 红黑树(RB tree)

**RB-tree(红黑树),**任何动态操作引发的结构变化量不至超过O(1)

建立在AVL树的基础上:

由红、黑两类节点组成的BST(统一增设外部节点NULL，使之成为真二叉树)

1. 树根：必为黑色

2. 外部节点：均为黑色

3. 其余节点，若为红，则只能有黑孩子 (红之子、之父比黑 )

4. 外部节点到根：途中黑节点数目相等 (黑深度)

   如下图，所画出来的为假想的外部节点.

   ![RB-tree.png](https://github.com/Realee007/jobbook/blob/master/src/image/RB-tree.png?raw=true)

   如果通过提升变化，可以将红黑树转换为4阶B-树. 

   具体地，自顶而下逐层考查红黑树各节点，每遇到一个红节点，都将对应的子树整体提升一层，从而与其父节点（必黑）水平对齐，二者之间的联边则相应调整为横向，由于考虑到条件(3)，同向者彼此不会相邻，所以涉及的节点至多3个，即构成4阶B-树的一个超级节点。

插入的新节点会涂为红色。

### AVL树

平衡二叉搜索树**(AVL树）**：在BST的基础上，要求任何节点的**左右子树高度**相**差**最多**1**。（重平衡的操作包括单旋和双旋，有一种统一的处理方法3+4重构）

### 二叉搜索树(BST)

任何节点的键值一定大于左子树的每一个节点的键值，并小于其右子树的每一个节点的键值(键值key可能和实值value相同也可能不同)。

插入：从根节点开始，遇键值大于待插入节点就向左，键值小于待插入节点就向右，一直到尾端。

删除：如果删除点A只有一个子节点，就直接把A的子节点连至A的父节点；如果A有两个子节点，我们就以右子树内最小节点取代A。



# 最小生成树算法



## 哈弗曼编码

# 图论基本算法

## DFS

- **优先选取最后一个被访问到的顶点的邻居。**

- 类似于树的先序遍历。

- 在遍历图时，对每个顶点至多调用一次DFS函数，因为一旦某个顶点被标志成已访问，就不再从它出发进行搜索。因此，遍历图的过程实质上是对每个顶点查找其邻接点的过程。

  其耗费的时间则取决于所采用的存储结构，当用二维数据表示邻接矩阵作图的存储结构时，查找每个顶点的邻接点所需时间为O(n^2)，其中n为图中顶点数。

  而当用邻接表作为图的存储结构时，找邻接点所需时间为O(e)，其中e为无向图中边的数或有向图中弧的数。由此当以邻接表作为存储结构时，时间复杂度为O(n+e).



- 时间复杂度: 邻接表：O(v+e). 邻接矩阵:O(v^2).
- 空间复杂度：O(v+e)



## BFS

- **越早被访问到的点，其邻居越优先被选用。**
- 每个顶点至多进一次队列。遍历图的过程实质上是通过边或弧找邻接点的过程。因此时间复杂度和DFS相同，不同之处仅仅在于对顶点访问的顺序不同。
- 时间复杂度: 邻接表：O(v+e). 邻接矩阵:O(v^2).
- 空间复杂度： 主要消耗在用于维护顶点访问次序的辅助队列O(n)、用于记录顶点O(n)和边状态O(e)的标志位向量。 即：O(v+e)



# 字符串匹配问题



## Kruskal算法

## Prim算法

# 动态规划

dynamic programming ,

颠倒计算方向：由自顶而下递归，为自底而上的迭代。

## fibonacci算法

最简单的例子是 斐波那契算法。

fib()，先根据fib(0)和fib(1)计算出fib(2)，然后保留fib(1)和fib(2)计算之后的fib(3)......依次迭代至fin(n)。 

```c++
int fib(int n)
{
    f = 0; g = 1;	//fib(0),fib(1)
    while(0<n--)
    {
        g = g+f;
        f = g-f;
    }
    return g;
}
```

此时空间复杂度：O(1)，时间复杂度：O(n)

​                                                 

## 最长公共子序列

最长公共子序列 LCS（longest common subsequence）: 两个序列公共子序列中的最长者。子序列：由序列中若干字符，按原相对次序构成。

比如 字符串"educational" 与"advantage"=>最长公共子串：data或dana

![LCS-1.png](https://github.com/Realee007/jobbook/blob/master/src/image/LCS-1.png?raw=true) 

```c++
//return LCS for a[0,n] and b[0,m].
int LCSUtil(string a, string b, int n, int m)
{
	if (n < 0 || m < 0)		//递归基
		return 0;
	if (a[n] == b[m])
	{
		return 1+LCSUtil(a, b, n-1, m-1);		//减而治之
	}
	else
	{
		//分而治之 沿两个方向求解取更长者
 		return std::max(LCSUtil(a, b, n-1, m),LCSUtil(a, b, n, m-1));
	}
}
int LCS(string a, string b)
{
	int n = a.size() - 1;
	int m = b.size() - 1;
	return LCSUtil(a, b, n, m);
}
```



但是该算法的时间复杂度，最坏为O(2^n)...指数坑...

- 为跳出指数时间复杂度的坑，应将递归转为为迭代。

  与fib()类似，这里也有大量的重复递归子问题，各子问题分别对应A和B的某个前缀组合。总共n*m种。

- 采用动态规划的策略

  只需要O(n*m)时间即可计算出所有子问题。

  1. 将所有子问题（假想）列为一张表。
  2. 颠倒计算方向从`LCS(a[0],b[0])`出发，**依次**计算所有项。 



![lcs-3.png](https://github.com/Realee007/jobbook/blob/master/src/image/lcs-3.png?raw=true)

```c++
int LCSdp(string a, string b)
{
// 	string a = "advantage";
// 	string b = "educational";
	int rows = a.size();
	int cols = b.size();
	vector<vector<int> > result (rows+1,vector<int>(cols+1,0));	//行 列为0

	for (int i = 1; i <= rows; ++i)
	{
		for (int j = 1; j <= cols; ++j)
		{
			int pre = max(result[i][j-1],result[i-1][j]);	//根据已知左邻、上邻

			if (a[i-1] == b[j-1])			//如果相等则看对角线的值
			{
				result[i][j] =result[i - 1][j - 1] + 1;
			}
			else
			{
				result[i][j]= pre;
			}
		}
	}
	return result[rows][cols];
} 
```

递归：设计出可行且正确的解。

动态规划：消除重复计算，提高效率。 



## 编辑距离 leetcode72

题目：给定两个字符串a,b，计算出a转换成b的最少操作数，编辑距离指的最少操作次数 。

转换的操作由三种：

1. 插入一个字符
2. 删除一个字符
3. 替换一个字符

```c++
输入: word1 = "horse", word2 = "ros"
输出: 3
解释: 
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**思路**： 分治思想，将复杂问题分解为相似的子问题。

假设字符串a,共m位,假如从1开始,即a[1,m]， 字符串b共 n 位, 即b[1,n]。

`d[i][j]`表示`a[1,j]`转换为`b[1,i]`的编辑距离。

那么有如下递归规律：()

1. 递归边界，
   1. 当`d[i][0]`时，a[1,0]即a为空时,所以编辑距离为 **i** 。
   2. 当`d[0][j]`时，b[1,0]即b为空时,所以编辑距离为 **j**。
2. 一般情况
   1. 当`a[i] = b[j]` 时，编辑距离`d[i][j]` = `d[i-1][j-1]`. 比如 a=fxy,b=fzy的编辑距离等于a=fx， b=fz。
   2. 当`a[i]!=b[j] `时，`d[i][j]`有三种转换操作可以选择，然后取最小值:
      1. 插入一个字符,此时 `d[i][j]` = `d[i][j-1]`+1。比如a=fxy,b=fzy的编辑距离等于fxy,fz的编辑距离 +1 .
      2. 删除一个字符,此时`d[i][j]` = `d[i-1][j]`+1。比如a = fxy,b=fzy的编辑距离等于a=fxyb,b=fzy的编辑距离+1.
      3. 替换一个字符,此时`d[i][j]` = `d[i-1][j-1]`+1.比如 a= fxy，b=fzy的编辑距离等于 fxy,fzy此时fx->fz的编辑距离+1（替换x为z）。

```c++
//按照上述,思路
int recursive(string a, int pos1,string b ,int pos2)
{
    if(pos1==0)
        return pos2;
    else if(pos2==0)
        return pos1;
    else if(a[pos1-1]==b[pos2-1])
        return recursive(a,pos1-1,b,pos2-1);
    else
    {
        return min(recursive(a,pos1-1,b,pos2),
                   min(recursive(a,pos1,b,pos2-1),recursive(a,pos1-1,b,pos2-1))
                  )+1;
    }    
}
int minDistance(string a, string b)
{
	return recursive(a,a.size(),b,b.size());
}
```

但是有个严重的问题，就是代码的性能很低下，时间复杂度是**指数**增长的.

上面的代码中，很多相同的子问题其实是经过了多次求解，解决这类问题的办法是用动态规划。

以字符串 a= "horse",b="ros"为例。

1. 首先建立一个矩阵，用来存放子问题和原问题的编辑距离，并将递归边界在矩阵中填好。

   ![dp-mindistance-1.png](https://github.com/Realee007/jobbook/blob/master/src/image/dp-mindistance-1.png?raw=true) 

2. 然后计算 i = 1, j = 1 所对应的编辑距离：比较 `a[i]` 和 `b[j]` 是否相等然后根据递归规律算出这个值 .![dp_mindistance-2.png](https://github.com/Realee007/jobbook/blob/master/src/image/dp_mindistance-2.png?raw=true) 

```c++
int minDistance(string word1, string word2) {
        
        int cols = word1.size();
        int rows = word2.size();
        vector<vector<int> > dpGrid (rows+1,vector<int>(cols+1,0));
        for(int i =0;i<=cols;++i)
        {
            dpGrid[0][i] = i;
        }
        for(int j =0;j<=rows;++j)
        {
            dpGrid[j][0] = j;
        }
        for(int i =1;i<=rows;++i)
        {
            for(int j = 1;j<=cols;++j)
            {
                if(word1[j-1]==word2[i-1])
                    dpGrid[i][j] = dpGrid[i-1][j-1];
                else
                {
                    dpGrid[i][j] = std::min(dpGrid[i-1][j],
                                            std::min(dpGrid[i-1][j-1],dpGrid[i][j-1]))+1;
                }
            }
        }
        return dpGrid[rows][cols];
    }
```

现在的时间复杂度已到了可接受范围，为 O(mn)。 

但是这个算法的空间复杂度为 O(mn)。是否可以再优化？

**根据具体问题优化空间复杂度**：

进一步分析，我们知道当计算橙色区域时，我们只需要蓝色这3块区域的值。同理，我们在计算当前行的时候，只需知道上一行即可。

![dp-mindistance-3.png](https://github.com/Realee007/jobbook/blob/master/src/image/dp-mindistance-3.png?raw=true) 

优化过后空间复杂度降低了，上述为 O(n) 。 时间复杂度还是 O(mn)。



# 哈希表

## 和为K的子数组 leetcode560

给定一个整数数组和一个整数 **k，**你需要找到该数组中和为 **k** 的连续的子数组的个数。 

```c++
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```

**思路：**

1. 暴力法（超时）

   可以列举出nums集合的对于每个index为起点的子集。然后计算sum=k的数目。

   时间复杂度：O(n^3)

   ```c++
   for(int start =0;start<nums.size();++start)
   {
       for(int end =start+1;end<=nums.size();++end)
       {
           int sum=0;
           for(int i =start;i<end;++i)
           {
               sum+=nums[i]
           }
           if(sum==k)
               count++;
       }
   }
   return count;
   ```

2. 累加式(AC)

   创建辅助数组sums存储原数据的每项和，如`nums={ 3,4,7,2,-3,1,4,2}`则`sums={0,3,7,14,16,13,14,18,20}`（第一项sum为0），然后根据sum[i]-sum[j] =k判断。

   时间复杂度:O(n^2)

   ```c++
   for(int start =0;start<nums.size();++start)
   {
       for(int end = start+1;end<=nums.size();++end)
       {
           if(sums[end]-sums[start]==k)
               count++;
       }
   }
   return count;
   ```

3. **hashmap**(AC)

   根据连续子数组的特点。`sum={0,3,7,14,16,13,14,18,20}`

   如果在获得sums[i]时，在已知的`sums[0,i-1]`中存在`sum[j] =sum[i]-k.(0<=j<=i-1)`,则count数加1。 于是在已知的容器中，使用hashmap的查找速度最快是O(1)。

   时间复杂度:O(n)

   ```c++
   hashmap.insert(make_pair(0,1));		//必须先存入(0,1)
   int sum =0;
   for(int i =0;i<nums.size();++i)
   {
       sum+=nums[i];
       if(hashmap.count(sum-k))		//count返回unordered_map中指定键对应的元素个数
           count+=hashmap[sum-k];
       hashmap[sum-k]++;
   }
   return count;
   ```




# 其他做题技巧和思路

## 树

### 二叉树的层次遍历：

 基于队列实现， 由于树是图的一种退化，从上至下的层次遍历本质上为广度优先遍历(BFS)。

### 二叉树的分行遍历：

在层次遍历的基础上，需要两个变量来实现每行的节点数。

1. 变量`toBePrinted`表示当前层还没打印的节点；
2. 变量`nextLevel`表示下一层的节点数。

### 二叉搜索树的后序遍历判定：

根据后序遍历的特点：最后的元素为根节点。BST的特点：（左子树）左孩子的值小于根节点，（右子树）右孩子的值大于根节点。

### 二叉搜索树的中序遍历：

特点：非降序排列。