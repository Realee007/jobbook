# 操作系统



## 用C++封装线程池

https://blog.csdn.net/gavingreenson/article/details/72770818



## 进程(process)和线程(thread)的区别

- 进程：具有一定独立功能的程序,进程是系统进行资源分配和调度的一个独立单位. 

- 线程:是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 

### 区别

https://blog.csdn.net/linraise/article/details/12979473

## 进程的通信方式---IPC(InterProcess Communication)

1. 管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。

2. 有名管道（named pipe）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。

3. 信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

4. 消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

5. 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。

6. 共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。
7. 套接字（socket）：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同及其间的进程通信。

https://blog.csdn.net/wh_sjc/article/details/70283843

## 线程间的通信机制 

线程间通信的主要目的是用于**线程同步**，所以**线程没有进程通信**中用于**数据交换**的通信机制。 

1. 锁机制
    	1. 互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。 
   	2.  读写锁：允许多个线程同时读共享数据，而对写操作互斥。
   	3.  条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 
2. 信号量机制：包括无名线程信号量与有名线程信号量
3. 信号机制：类似进程间的信号处理。

## 进程中断

进程的中断是归类于**异常**。在进程运行的过程中，处理器检测到事件（event），并确定异常号，随后触发异常，转到相应的处理程序。异常表的起始地址放在**异常表基址寄存器**（特殊CPU寄存器）。

具体的异常分为四类：

| 类别 | 原因              | 异步/同步 | 返回行为           |
| ---- | ----------------- | --------- | ------------------ |
| 中断 | 来自I/O设备的信号 | 异步      | 返回下一条指令     |
| 陷阱 | 有意的异常        | 同步      | 返回下一条指令     |
| 故障 | 潜在可恢复的错误  | 同步      | 可能返回到当前指令 |
| 终止 | 不可恢复的错误    | 同步      | 不会返回           |

异常的异步和同步理解：

中断有两种，一种是CPU本身在执行程序的过程中产生的，一种是由CPU外部产生的。

1. 外部中断，就是通常所讲的“中断”（interrupt）。对于执行程序来说，这种“中断”的发生完全是异步的，因为不知道什么时候会发生。CPU对其的响应也完全是被动的，可以通过“关中断”指令关闭对其的响应。  
2. 由软件产生的中断一般是由专设的指令，如X86中的“INT n”在程序中有意产生的是主动的，同步的。只要CPU执行一条INT指令，在开始执行下一条指令之前一定会进入中  断服务程序。这种主动的中断称故障指令。  

## 进程饥饿 

在操作系统中，多个进程同时运行时，系统需要确定一个资源分配策略给进程，以提高计算机的吞吐量。如CPU调度，有些**调度是不公平的**，如优先级调度算法。某些已就绪的进程因长时间的等待CPU从而发送**饥饿（无期限的阻塞）**。

实例： 多个thread阻塞在同一个mutex上，系统调度器会选择其中一个接触阻塞状态，而选择的方式有可能造成某个不幸的thread永远也不会解除阻塞进入运行状态。

 低优先级进程的饥饿的解决方法之一是**老化（aging）**，即逐渐增加在系统中等待很长时间的进程的优先级。



## 部分词语解释

### 上下文（context）：

因为程序都运行在某个进程的上下文中，上下文是由程序正确运行所需的状态组成。这个状态包括：存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。

### 上下文切换

- 当内核代表用户执行系统调用时会发生上下文切换。 
- 中断也会引发上下文切换

上下文切换的具体操作：

1. 保存当前进程的上下文
2. 恢复某个先前被抢占的进程被保存的上下文
3. 将控制传递给这个新恢复的进程。

## 并发和并行区别

并发是两个队列交替使用一台咖啡机，并行是两个队列同时使用两台咖啡机。

并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）cpu执行，如果可以就说明是并行，而并发是多个线程被（一个）cpu 轮流切换着执行。