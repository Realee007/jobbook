# 排序算法

## 交换算法

### 快速排序

### 归并排序







# 高级搜索树

## AVL树 



## 红黑树(RB tree)



## 伸展树（splay tree）

特点：

- 无需记录节点高度或平衡因子;编程实现简单易行——优于AVL树

  分摊复杂度O(logn)——与AVL树相当

- 局部性强，缓存命中率极高(即k<< n<< m)

  > 对于一棵节点为n的伸展树，假设经常操作的节点为k，则由于“双层伸展调节”的特性，使得伸展树的k个节点集中在根节点处，从而提高了这k个节点的命中率。
  >
  > 通常操作系统会利用这点，使缓存利用率尽可能提高。这就是为什么新电脑再使用一段时间后更顺手。

  ​	效率甚至可以更高——自适应的O(logk)

  ​	任何连续的m次查找，都可以在O(mlogk +nlogn)时间内完成。（在达到logk之前，需要达到常规的n次操作，每次是logn。）

- 仍不能保证的单次最坏情况的出现，不适用于对效率敏感的场合。

  >  比如在手术室里，控制手术器械的程序，绝不能使用伸展树这类数据结构

  伸展树时间复杂度的严格证明参考:邓俊辉数据结构习题8-2.

## B-树(B tree) 

平衡的多路搜索树。

- 所谓m阶B-树，即m路平衡搜索树(m>=2)，

- B-树结构适用于在相对更小的内存中，实现对大规模数据的高效操作。其原因是将活跃的B树根节点常驻于内存，而其他大数据集存放于外存，只载入必需的节点，尽可能减少I/O操作。(实现上通过指向外部节点的引用实现, **不同存储级别的串接**)

- m阶的B-树内部节点中

  关键码n: n<=m-1,则有n+1个分支。

  树根：2<= n+1,(至少两个分支)

  内部节点的分支数n+1,  ceil(m/2)<= n+1<=m . 

- 故称为
  $$
  (\left \lceil m/2 \right \rceil,m) 树
  $$







​	如下图，4阶B树，高度为3，其中每个节点包含1~3个关键码，拥有2~4个分支。

​	(a)最基础表示——>(b)关键码保留，将引用转化为一个点——>(c)省略掉外部节点.

- 所有**叶节点**的深度统一相等。但B树中定义了一种外部节点（即叶节点中数值为空且并不存在的孩子）

![B-tree.png](https://github.com/Realee007/jobbook/blob/master/src/image/B-tree.png?raw=true) 


- 定义：节点可以用向量vector表示，同一节点的所有孩子组织为一个向量，孩子向量的实际长度比关键码向量多一。（为了与I/O操作的延迟相匹配，**每个节点的大小**应该尽可能设计为与**一次I/O兑换的页面相匹配(200~300)**。）

- 操作：查找，基于vector顺序查找，若某层查找失败，则沿着引用不断深入下一层（每一次的深入可以看成，将节点载入到内存），直至某一关键码命中（成功），或到达某一个外部节点（no1,no.2）。 no1. 查找失败，2. 这个外部引用存放的是一个更低层次级别的B树（看成不同存储级别的B树串接）

- 动态操作步骤

  **查找**：对于N个关键码的m阶B-树，耗时不超过O(logmN)

  **插入**：相对复杂，首先是查找该关键码至某一外部节点v，且其父节点必然为某一节点p。于是在该p中查找并确定插入的位置r.如果插入的过程中该节点出现**上溢**，则以中位数为界进行分裂，并将中位数上身一层，并以分裂的子节点作为左右孩子，极端情况是分裂到根，导致**B-树长高**。 耗时不超过O(logmN)

  删除:更复杂，首先也是查找，但是删除某关键码会导致该节点的关键码总数过少(小于ceil(m/2)-1),则发生**下溢**。左顾右盼兄弟节点，向其借关键码或合并，在进行合并操作可能导致父节点下溢，这种操作会不断向根节点蔓延直到树根，若合并后根的关键码为空，导致**B-树降低**。耗时不超过O(logmN)

- 水平操作: 内存操作:RAM， 垂直操作:Disk。



1. 作用：B树的动机实现高效的I/O。

> 对于典型的计算机模型，自上而下CPU<——>RAM<——>DISK<——>ARRAY... 相对任何一个存储级别，如果希望**向更低**的存储级别**写入**或**从更低**的存储级别**读入**数据。我们称之为输出和输入，简称I/O。
>
> 对于上层存储器而言，对底层存储器的访问都称为**外存访问**。
>
> 以磁盘和内存为例，两者访问速度是ms与ns之差(10^5)。



2. 相对比AVL：

多层考察，即将父子节点合并为超级节点。每n代合并, 类比于二路搜索路，每个超级节点有m = 2^d路分支。m-1个关键码。

多级存储系统使用B-树，可针对外部查找，大大减少I/O次数。

相比**AVL**树，如果有n = 1G个记录，每次查找需要log(2,10^9) = **30 次I/O**操作，每次只能读**一个**关键码.

而B树，由于充分利用外存对**批量访问**的高效支持，将此**特点**转化为优点。每下降一层，都以**超级节点**为单位，读入**一组**关键码。

具体多大一组？取决于磁盘数据卡的大小.比如目前多数数据卡采用m = 200~300.

假如m = 256,则**B树**每次查找只需要log(256,10^9) <= **4次I/O**



## B+树(B plus Tree)

B+树是B-树的一种变形。有着比B-树更高的性能。

相比B树有相同的特点，但是在B+树中

内部节点只存储index(not elements)和pointer.

**外部节点才存储data**.并且外部节点通过**双向链表**连接。好处是对于范围查询，在查找的过程中不需要从根开始，而是根据双向链表直接查找，节省查找时间。



## B树 vs B+树



B-树就是B树。

数据库以B树格式储存，只解决了按照"主键"查找数据的问题。如果想查找其他字段，就需要建立索引（index）。 

https://blog.csdn.net/v_JULY_v/article/details/6530142/